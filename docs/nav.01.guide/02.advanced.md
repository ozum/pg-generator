# Advanced

## CLI vs API

pg-generator may be used as CLI or as API. To use it as a CLI tool, execute the `pgen` command. To use via API within Node.js, import and execute async `generate` function. Options for CLI and API are the same most of the time.

```bash
$ pgen example --outDir models
```

is equal to

```
await generate("example" { outDir: "models" });
```

## Context

Generators may add and use extra context data which may be used as a configuration for the templates they provide. It should be described in the generator's documents. You may provide a context file or a context module to override those values and modify the behavior of the template.

For example `pg-generator-example`s "sequelize6" sub-generator uses `global.addSchemaName` boolean value to determine whether to include PostgreSQL schema names to the created object's names.

With the `contextFile` option, you can provide a path to a JSON file or a JavaScript file that exports a context object as default.

```bash
$ pgen example:sequelize6 --outDir models --contextFile path/to/my-context.js
```

**path/to/my-context.js**

```js
module.exports = {
  global: {
    addSchemaName: false,
  },
};
```

## Relation Names

pg-generator uses pg-structure to reverse engineer a PostgreSQL Database. Since databases do not have actual relations and relation names, naming a relation is an opinionated process. You can use built-in functions or provide your naming functions using `relationNameFunctions` option.

Below is the summary of built-in methods:

| Built-in Functions | Type              | Features                                                                                               |
| ------------------ | ----------------- | ------------------------------------------------------------------------------------------------------ |
| `short`            | Deterministic     | Produces short names, but may result in naming collisions, if the database contains complex relations. |
| `descriptive`      | Deterministic     | Produces long names especially if foreign keys are named well. Less chance of naming collisions.       |
| `optimal`          | Non-Deterministic | Produces short names where possible, otherwise produces descriptive names.                             |

See [latest documentation](https://www.pg-structure.com/nav.01.guide/guide--nc/relation-names) about relation naming methods.

If you would like to use your relation name functions create a file exporting `m2m`, `m2o`, and `m2m` functions, and provide the path of the file using `relationNameFunctions` option.

```ts
export function o2m(relation: O2MRelation): string {},
export function m2o(relation: M2ORelation): string {},
export function m2m(relation: M2MRelation): string {},
```

Please see documentation for [relation name functions](https://www.pg-structure.com/nav.02.api/#relationnamefunctions).

Input arguments are corresponding relations. Relation objects provide a rich set of data via attributes. You can generate the relation name using that information according to your needs. See documentation for [O2MRelation Class](https://www.pg-structure.com/nav.02.api/classes/o2mrelation.html#class-o2mrelation), [M2ORelation Class](https://www.pg-structure.com/nav.02.api/classes/m2orelation.html#class-m2orelation), [M2MRelation Class](https://www.pg-structure.com/nav.02.api/classes/m2mrelation.html#class-m2mrelation).

## Including & Excluding Schemas

If you want to include or exclude specific schemas, you can use `includeSchemas` and `excludeSchemas` options, or their alias `-i` and `-e`. Their syntax is the same.

For example, to include all schemas starting with "public\_", use the following:

```bash
$ pgen example -i: "public_%"
```

or to include only "public" and "extra" schemas, use the "-i" alias multiple times as the following:

```bash
$ pgen example -i public -i extra
```
